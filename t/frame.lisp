(in-package :cl-amqp.test)

(enable-binary-string-syntax)

(plan 9)

(subtest "Frames Parsing"

  (subtest "Single-byte payload"
    (let* ((frame-type)
           (channel-number)
           (payload-size)
           (payload-start)
           (payload-end)
           (frame-ended)
           (parser (amqp:make-frame-parser
                    :on-frame-type (lambda (parser frame-type%)
                                     (declare (ignore parser))
                                     (setf frame-type frame-type%))
                    :on-frame-channel (lambda (parser frame-channel)
                                        (declare (ignore parser))
                                        (setf channel-number frame-channel))
                    :on-frame-payload-size (lambda (parser frame-payload-size%)
                                             (declare (ignore parser))
                                             (setf payload-size frame-payload-size%))
                    :on-frame-payload (lambda (parser data start end)
                                        (declare (ignore parser data))
                                        (setf payload-start start
                                              payload-end end))
                    :on-frame-end (lambda (parser)
                                    (declare (ignore parser))
                                    (setf frame-ended t)))))
      (amqp:frame-parser-consume parser #b"\x3\x0\x3\x0\x0\x0\x01a\xCE")
      (is frame-type 3 "FRAME-TYPE should be 3")
      (is channel-number 3 "CHANNEL-NUMBER should be 3")
      (is payload-size 1 "PAYLOAD-SIZE should be 1")
      (is payload-start 7 "PAYLOAD always starts at 7")
      (is payload-end 8 "PAYLOAD ends at 8")
      (is frame-ended t "FRAME ended with 0xCE")))

  (subtest "No payload"
    (let* ((frame-type)
           (channel-number)
           (payload-size)
           (payload-start)
           (payload-end)
           (frame-ended)
           (parser (amqp:make-frame-parser
                    :on-frame-type (lambda (parser frame-type%)
                                     (declare (ignore parser))
                                     (setf frame-type frame-type%))
                    :on-frame-channel (lambda (parser frame-channel)
                                        (declare (ignore parser))
                                        (setf channel-number frame-channel))
                    :on-frame-payload-size (lambda (parser frame-payload-size%)
                                             (declare (ignore parser))
                                             (setf payload-size frame-payload-size%))
                    :on-frame-payload (lambda (parser data start end)
                                        (declare (ignore parser data))
                                        (setf payload-start start
                                              payload-end end))
                    :on-frame-end (lambda (parser)
                                    (declare (ignore parser))
                                    (setf frame-ended t)))))
      (amqp:frame-parser-consume parser #b"\x3\x0\x3\x0\x0\x0\x0\xCE")
      (is frame-type 3 "FRAME-TYPE should be 3")
      (is channel-number 3 "CHANNEL-NUMBER should be 3")
      (is payload-size 0 "PAYLOAD-SIZE should be 0")
      (is payload-start nil "PAYLOAD-START should be NIL")
      (is payload-end nil "PAYLOAD-END should be NIL")
      (is frame-ended t "FRAME ended with 0xCE")))

  (subtest "Single-buffer read"
    (let* ((frame-type)
           (channel-number)
           (payload-size)
           (payload-start)
           (payload-end)
           (frame-ended)
           (parser (amqp:make-frame-parser
                    :on-frame-type (lambda (parser frame-type%)
                                     (declare (ignore parser))
                                     (setf frame-type frame-type%))
                    :on-frame-channel (lambda (parser frame-channel)
                                        (declare (ignore parser))
                                        (setf channel-number frame-channel))
                    :on-frame-payload-size (lambda (parser frame-payload-size%)
                                             (declare (ignore parser))
                                             (setf payload-size frame-payload-size%))
                    :on-frame-payload (lambda (parser data start end)
                                        (declare (ignore parser data))
                                        (setf payload-start start
                                              payload-end end))
                    :on-frame-end (lambda (parser)
                                    (declare (ignore parser))
                                    (setf frame-ended t)))))
      (amqp:frame-parser-consume parser #b"\x16\x0\x3\x0\x0\x0\xcHello World!\xce")
      (is frame-type 22 "FRAME-TYPE should be 22")
      (is channel-number 3 "CHANNEL-NUMBER should be 3")
      (is payload-size 12 "PAYLOAD-SIZE should be 12")
      (is payload-start 7 "PAYLOAD always starts at 7")
      (is payload-end 19 "PAYLOAD ends at 19")
      (is frame-ended t "FRAME ended with 0xCE")))

  (subtest "Shifted Single-buffer read"
    (let* ((frame-type)
           (channel-number)
           (payload-size)
           (payload-start)
           (payload-end)
           (frame-ended)
           (parser (amqp:make-frame-parser
                    :on-frame-type (lambda (parser frame-type%)
                                     (declare (ignore parser))
                                     (setf frame-type frame-type%))
                    :on-frame-channel (lambda (parser frame-channel)
                                        (declare (ignore parser))
                                        (setf channel-number frame-channel))
                    :on-frame-payload-size (lambda (parser frame-payload-size%)
                                             (declare (ignore parser))
                                             (setf payload-size frame-payload-size%))
                    :on-frame-payload (lambda (parser data start end)
                                        (declare (ignore parser data))
                                        (setf payload-start start
                                              payload-end end))
                    :on-frame-end (lambda (parser)
                                    (declare (ignore parser))
                                    (setf frame-ended t)))))
      (amqp:frame-parser-consume parser #b"\x0\x0\x0\x16\x0\x3\x0\x0\x0\xcHello World!\xce\x0\x0\x0" :start 3 :end 23)
      (is frame-type 22 "FRAME-TYPE should be 22")
      (is channel-number 3 "CHANNEL-NUMBER should be 3")
      (is payload-size 12 "PAYLOAD-SIZE should be 12")
      (is payload-start 10 "PAYLOAD always starts at 10")
      (is payload-end 22 "PAYLOAD ends at 22")
      (is frame-ended t "FRAME ended with 0xCE")))

  (subtest "Splitted-buffer read"
    (let* ((frame-type)
           (channel-number)
           (payload-size)
           (payload-bounds)
           (frame-ended)
           (parser (amqp:make-frame-parser
                    :on-frame-type (lambda (parser frame-type%)
                                     (declare (ignore parser))
                                     (setf frame-type frame-type%))
                    :on-frame-channel (lambda (parser frame-channel)
                                        (declare (ignore parser))
                                        (setf channel-number frame-channel))
                    :on-frame-payload-size (lambda (parser frame-payload-size%)
                                             (declare (ignore parser))
                                             (setf payload-size frame-payload-size%))
                    :on-frame-payload (lambda (parser data start end)
                                        (declare (ignore parser data))
                                        (setf payload-bounds (append payload-bounds (list (cons start end)))))
                    :on-frame-end (lambda (parser)
                                    (declare (ignore parser))
                                    (setf frame-ended t)))))
      (amqp:frame-parser-consume parser #b"\x16\x0\x3\x0\x0\x0\xcHell")
      (amqp:frame-parser-consume parser #b"o World!\xce")
      (is frame-type 22 "FRAME-TYPE should be 22")
      (is channel-number 3 "CHANNEL-NUMBER should be 3")
      (is payload-size 12 "PAYLOAD-SIZE should be 12")
      (is payload-bounds '((7 . 11) (0 . 8)) "Frame parsed from two reads with payload bounds ((7 . 11) (0 . 8))")
      (is frame-ended t "FRAME ended with 0xCE")))

  (subtest "Shifted Splitted-buffer read"
    (let* ((frame-type)
           (channel-number)
           (payload-size)
           (payload-bounds)
           (frame-ended)
           (parser (amqp:make-frame-parser
                    :on-frame-type (lambda (parser frame-type%)
                                     (declare (ignore parser))
                                     (setf frame-type frame-type%))
                    :on-frame-channel (lambda (parser frame-channel)
                                        (declare (ignore parser))
                                        (setf channel-number frame-channel))
                    :on-frame-payload-size (lambda (parser frame-payload-size%)
                                             (declare (ignore parser))
                                             (setf payload-size frame-payload-size%))
                    :on-frame-payload (lambda (parser data start end)
                                        (declare (ignore parser data))
                                        (setf payload-bounds (append payload-bounds (list (cons start end)))))
                    :on-frame-end (lambda (parser)
                                    (declare (ignore parser))
                                    (setf frame-ended t)))))
      (amqp:frame-parser-consume parser #b"\x0\x0\x0\x16\x0\x3\x0\x0\x0\xcHell\x0\x0\x0\x0" :start 3 :end 14)
      (amqp:frame-parser-consume parser #b"\x0\x0o World!\xce\x0" :start 2 :end 11)
      (is frame-type 22 "FRAME-TYPE should be 22")
      (is channel-number 3 "CHANNEL-NUMBER should be 3")
      (is payload-size 12 "PAYLOAD-SIZE should be 12")
      (is payload-bounds '((10 . 14) (2 . 10)) "Frame parsed from two reads with payload bounds ((10 . 14) (2 . 10))")
      (is frame-ended t "FRAME ended with 0xCE")))

  (subtest "Frames Sequence"
    (let* ((frames-count 0)
           (frame-types)
           (channel-numbers)
           (payload-sizes)
           (payload-bounds)
           (frame-ended)
           (parser (amqp:make-frame-parser
                    :on-frame-type (lambda (parser frame-type)
                                     (declare (ignore parser))
                                     (setf frame-types (append frame-types (list frame-type))))
                    :on-frame-channel (lambda (parser frame-channel)
                                        (declare (ignore parser))
                                        (setf channel-numbers (append channel-numbers (list frame-channel))))
                    :on-frame-payload-size (lambda (parser frame-payload-size)
                                             (declare (ignore parser))
                                             (setf payload-sizes (append payload-sizes (list frame-payload-size))))
                    :on-frame-payload (lambda (parser data start end)
                                        (declare (ignore parser data))
                                        (setf payload-bounds (append payload-bounds (list (cons start end)))))
                    :on-frame-end (lambda (parser)
                                    (declare (ignore parser))
                                    (incf frames-count)
                                    (setf frame-ended t)))))
      (amqp:frame-parser-consume parser #b"\x0\x0\x0\x16\x0\x3\x0\x0\x0\xcHell\x0\x0\x0\x0" :start 3 :end 14)
      (amqp:frame-parser-consume parser #b"o World!\xCE\x3\x0\x2\x0\x0\x0\x0" :start 0 :end 14)
      (amqp:frame-parser-consume parser #b"\x0\x01a\xCE\x0\x0\x0" :start 0 :end 4)
      (is frames-count 2 "FRAME-COUNT should be 2")
      (is frame-types '(22 3) "FRAME-TYPES should be 22 and 3")
      (is channel-numbers '(3 2) "CHANNEL-NUMBERS should be 3 and 2")
      (is payload-sizes '(12 1) "PAYLOAD-SIZES should be 12 and 1")
      (is payload-bounds '((10 . 14) (0 . 8) (2 . 3)) "Frames parsed from 3 reads with payload bounds ((10 . 14) (0 . 8) (2 . 3))")
      t))

  (subtest "No 0xCE at the end"
    (let ((parser (amqp:make-frame-parser)))
      (is-error (amqp:frame-parser-consume parser #b"\x3\x0\x3\x0\x0\x0\x01a\x12\x1")
                'amqp:malformed-frame-error
                "PARSER should throw MALFORMED-FRAME-ERROR if frame end is not 0xCE")))

  (subtest "Invalid parser state"
    (let ((parser (amqp:make-frame-parser)))
      (is-error (progn
                  (amqp:frame-parser-consume parser #b"\x3\x0\x3\x0\x0")
                  (setf (slot-value parser 'amqp::state) -1)
                  (amqp:frame-parser-consume parser #b"\x0\x01a\xCE"))
                'amqp:invalid-frame-parser-state-error
                "PARSER should throw INALID-FRAME-PARSER-STATE-ERROR if frame parser state is invalid/unknown"))))

(subtest "Frame types"
  (subtest "Frame class from frame type" ;; TODO: sometime later this will be redundant
    (is 'amqp::method-frame (amqp:frame-class-from-frame-type 1) "Method Frame type: 1")
    (is 'amqp::header-frame (amqp:frame-class-from-frame-type 2) "Header Frame type: 2")
    (is 'amqp::body-frame (amqp:frame-class-from-frame-type 3) "Body Frame type: 3")
    (is 'amqp::heartbeat-frame (amqp:frame-class-from-frame-type 4) "Heartbeat Frame type: 4")
    (is-error (amqp:frame-class-from-frame-type 11) 'amqp:amqp-unknown-frame-type-error
              "Frame type 11 generates amqp-unknown-frame-type-error")))

(finalize)
  
